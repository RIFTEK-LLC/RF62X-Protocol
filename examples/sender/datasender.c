#include "smartchannel.h"
#include "smartmsg.h"

#include <mpack/mpack.h>
#include <string.h>
#include <stdio.h>

#include<time.h>
void delay(unsigned int mseconds)
{
    clock_t goal = mseconds + clock();
    while (goal > clock());
}

uint32_t answ_count = 0;
uint32_t receiver_id = 1;
int8_t smart_short_data_callback(char* data, uint32_t data_size, uint32_t data_device_id, void* rqst_msg)
{
    answ_count++;
    printf("+ Get answer to %s command, rqst-id: %" PRIu64 ", payload size: %d\n",
           ((smart_msg_t*)rqst_msg)->cmd_name, ((smart_msg_t*)rqst_msg)->_uid, data_size);

    int32_t status = SMART_PARSER_RETURN_STATUS_NO_DATA;

    if (data_device_id == receiver_id)
    {
        smart_msg_t* msg = rqst_msg;
        typedef struct
        {
            char* received_data;
        }answer;

        if (msg->result == NULL)
        {
            msg->result = calloc(1, sizeof (answer));
        }

        ((answer*)msg->result)->received_data = calloc(data_size + 1, sizeof (char));
        memcpy(((answer*)msg->result)->received_data, data, data_size);

        status = SMART_PARSER_RETURN_STATUS_DATA_READY;
    }
    return status;
}
int8_t smart_short_data_timeout_callback(void* rqst_msg)
{
    smart_msg_t* msg = rqst_msg;

    printf("- Get timeout to %s command, rqst-id: %" PRIu64 ".\n",
           msg->cmd_name, msg->_uid);

    return TRUE;
}
int8_t smart_short_data_free_result_callback(void* rqst_msg)
{
    smart_msg_t* msg = rqst_msg;

    printf("- Free result to %s command, rqst-id: %" PRIu64 ".\n",
           msg->cmd_name, msg->_uid);

    if (msg->result != NULL)
    {
        typedef struct
        {
            char* received_data;
        }answer;

        free(((answer*)msg->result)->received_data);
        free(msg->result);
        msg->result = NULL;
    }

    return TRUE;
}


int main(int argc, char* argv[])
{
    printf("##############################\n");
    printf("#                            #\n");
    printf("#    Data Sender Test v2.0   #\n");
    printf("#                            #\n");
    printf("##############################\n\n");

    char* version = smart_channel_version();
    printf("Smart-protocol version: %s\n\n", version);


    char config[1024] = {0};

    if (argc > 1)
    {
        printf("\n\n## CURRENT SETTINGS ##\n\n");
        for (int i = 1; i < argc; i+=2)
            printf("%s\t: %s\n", &argv[i][1], argv[i+1]);
        printf("\n");
        int len = 0;
        for (int i = 1; i < argc; i++)
        {
            int size = strlen(argv[i]);
            if (size > 0 && (len + size + 1 <= (int)sizeof (config)))
            {
                strncpy(&config[len], argv[i], size);
                len += strlen(argv[i]);
                strncpy(&config[len], " ", 1);
                len += 1;
            }
        }
    }else
    {
        uint32_t src_device_uid = 2;
        char* dst_ip_addr = "192.168.1.2";
        char* host_ip_addr = "192.168.1.30";
        uint32_t in_udp_port = 50021;
        uint32_t out_udp_port = 50021;
        uint32_t socket_timeout = 100;
        uint32_t max_packet_size = 65535;
        uint32_t max_data_size = 20000000;
        sprintf(config,
                "-src_device_uid %d "
                "-dst_ip_addr %s "
                "-host_ip_addr %s "
                "-in_udp_port %d "
                "-out_udp_port %d "
                "-socket_timeout %d "
                "-max_packet_size %d "
                "-max_data_size %d",
                src_device_uid, dst_ip_addr, host_ip_addr, in_udp_port, out_udp_port,
                socket_timeout, max_packet_size, max_data_size);

        printf("## DEFAULT SETTINGS ##\n\n"
               "src_device_uid\t: %d\n"
               "dst_ip_addr\t: %s\n"
               "host_ip_addr\t: %s\n"
               "in_udp_port\t: %d\n"
               "out_udp_port\t: %d\n"
               "socket_timeout\t: %d\n"
               "max_packet_size\t: %d\n"
               "max_data_size\t: %d\n\n",
               src_device_uid, dst_ip_addr, host_ip_addr, in_udp_port, out_udp_port,
               socket_timeout, max_packet_size, max_data_size);
    }
    smart_channel channel;

    smart_channel_init(&channel, config);

    // Create short data msg for testing payload mode.
    char short_data[] = { 0x82, 0xA7, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74,
                          0xC3, 0xA6, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00 };

    // Create long data msg for testing chain mode.
    char long_data[] =  { 0xde, 0x00, 0x18, 0xa4, 0x69, 0x6e, 0x74, 0x30, 0x00,
                          0xa4, 0x69, 0x6e, 0x74, 0x31, 0x01, 0xa8, 0x69, 0x6e,
                          0x74, 0x31, 0x5f, 0x6e, 0x65, 0x67, 0xff, 0xa4, 0x69,
                          0x6e, 0x74, 0x38, 0xcc, 0xff, 0xa8, 0x69, 0x6e, 0x74,
                          0x38, 0x5f, 0x6e, 0x65, 0x67, 0xd1, 0xff, 0x01, 0xa5,
                          0x69, 0x6e, 0x74, 0x31, 0x36, 0xcd, 0x01, 0x00, 0xa9,
                          0x69, 0x6e, 0x74, 0x31, 0x36, 0x5f, 0x6e, 0x65, 0x67,
                          0xd1, 0xff, 0x00, 0xa5, 0x69, 0x6e, 0x74, 0x33, 0x32,
                          0xce, 0x00, 0x01, 0x00, 0x00, 0xa9, 0x69, 0x6e, 0x74,
                          0x33, 0x32, 0x5f, 0x6e, 0x65, 0x67, 0xd2, 0xff, 0xff,
                          0x00, 0x00, 0xa3, 0x6e, 0x69, 0x6c, 0xc0, 0xa4, 0x74,
                          0x72, 0x75, 0x65, 0xc3, 0xa5, 0x66, 0x61, 0x6c, 0x73,
                          0x65, 0xc2, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0xcb,
                          0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa9,
                          0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x6e, 0x65, 0x67,
                          0xcb, 0xbf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xa7, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x30, 0xa0,
                          0xa7, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x31, 0xa1,
                          0x41, 0xa7, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x34,
                          0xa9, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x62, 0x61,
                          0x7a, 0xa7, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x38,
                          0xb8, 0x4f, 0x6d, 0x6e, 0x65, 0x73, 0x20, 0x76, 0x69,
                          0x61, 0x65, 0x20, 0x52, 0x6f, 0x6d, 0x61, 0x6d, 0x20,
                          0x64, 0x75, 0x63, 0x75, 0x6e, 0x74, 0x2e, 0xa8, 0x73,
                          0x74, 0x72, 0x69, 0x6e, 0x67, 0x31, 0x36, 0xda, 0x02,
                          0x81, 0x4c, 0xe2, 0x80, 0x99, 0x68, 0x6f, 0x6d, 0x6d,
                          0x65, 0x20, 0x6e, 0xe2, 0x80, 0x99, 0x65, 0x73, 0x74,
                          0x20, 0x71, 0x75, 0xe2, 0x80, 0x99, 0x75, 0x6e, 0x20,
                          0x72, 0x6f, 0x73, 0x65, 0x61, 0x75, 0x2c, 0x20, 0x6c,
                          0x65, 0x20, 0x70, 0x6c, 0x75, 0x73, 0x20, 0x66, 0x61,
                          0x69, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x65, 0x20, 0x6c,
                          0x61, 0x20, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20,
                          0x3b, 0x20, 0x6d, 0x61, 0x69, 0x73, 0x20, 0x63, 0xe2,
                          0x80, 0x99, 0x65, 0x73, 0x74, 0x20, 0x75, 0x6e, 0x20,
                          0x72, 0x6f, 0x73, 0x65, 0x61, 0x75, 0x20, 0x70, 0x65,
                          0x6e, 0x73, 0x61, 0x6e, 0x74, 0x2e, 0x20, 0x49, 0x6c,
                          0x20, 0x6e, 0x65, 0x20, 0x66, 0x61, 0x75, 0x74, 0x20,
                          0x70, 0x61, 0x73, 0x20, 0x71, 0x75, 0x65, 0x20, 0x6c,
                          0xe2, 0x80, 0x99, 0x75, 0x6e, 0x69, 0x76, 0x65, 0x72,
                          0x73, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x65, 0x72, 0x20,
                          0x73, 0xe2, 0x80, 0x99, 0x61, 0x72, 0x6d, 0x65, 0x20,
                          0x70, 0x6f, 0x75, 0x72, 0x20, 0x6c, 0xe2, 0x80, 0x99,
                          0xc3, 0xa9, 0x63, 0x72, 0x61, 0x73, 0x65, 0x72, 0x20,
                          0x3a, 0x20, 0x75, 0x6e, 0x65, 0x20, 0x76, 0x61, 0x70,
                          0x65, 0x75, 0x72, 0x2c, 0x20, 0x75, 0x6e, 0x65, 0x20,
                          0x67, 0x6f, 0x75, 0x74, 0x74, 0x65, 0x20, 0x64, 0xe2,
                          0x80, 0x99, 0x65, 0x61, 0x75, 0x2c, 0x20, 0x73, 0x75,
                          0x66, 0x66, 0x69, 0x74, 0x20, 0x70, 0x6f, 0x75, 0x72,
                          0x20, 0x6c, 0x65, 0x20, 0x74, 0x75, 0x65, 0x72, 0x2e,
                          0x20, 0x4d, 0x61, 0x69, 0x73, 0x2c, 0x20, 0x71, 0x75,
                          0x61, 0x6e, 0x64, 0x20, 0x6c, 0xe2, 0x80, 0x99, 0x75,
                          0x6e, 0x69, 0x76, 0x65, 0x72, 0x73, 0x20, 0x6c, 0xe2,
                          0x80, 0x99, 0xc3, 0xa9, 0x63, 0x72, 0x61, 0x73, 0x65,
                          0x72, 0x61, 0x69, 0x74, 0x2c, 0x20, 0x6c, 0xe2, 0x80,
                          0x99, 0x68, 0x6f, 0x6d, 0x6d, 0x65, 0x20, 0x73, 0x65,
                          0x72, 0x61, 0x69, 0x74, 0x20, 0x65, 0x6e, 0x63, 0x6f,
                          0x72, 0x65, 0x20, 0x70, 0x6c, 0x75, 0x73, 0x20, 0x6e,
                          0x6f, 0x62, 0x6c, 0x65, 0x20, 0x71, 0x75, 0x65, 0x20,
                          0x63, 0x65, 0x20, 0x71, 0x75, 0x69, 0x20, 0x6c, 0x65,
                          0x20, 0x74, 0x75, 0x65, 0x2c, 0x20, 0x70, 0x75, 0x69,
                          0x73, 0x71, 0x75, 0xe2, 0x80, 0x99, 0x69, 0x6c, 0x20,
                          0x73, 0x61, 0x69, 0x74, 0x20, 0x71, 0x75, 0xe2, 0x80,
                          0x99, 0x69, 0x6c, 0x20, 0x6d, 0x65, 0x75, 0x72, 0x74,
                          0x2c, 0x20, 0x65, 0x74, 0x20, 0x6c, 0xe2, 0x80, 0x99,
                          0x61, 0x76, 0x61, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x20,
                          0x71, 0x75, 0x65, 0x20, 0x6c, 0xe2, 0x80, 0x99, 0x75,
                          0x6e, 0x69, 0x76, 0x65, 0x72, 0x73, 0x20, 0x61, 0x20,
                          0x73, 0x75, 0x72, 0x20, 0x6c, 0x75, 0x69, 0x2c, 0x20,
                          0x6c, 0xe2, 0x80, 0x99, 0x75, 0x6e, 0x69, 0x76, 0x65,
                          0x72, 0x73, 0x20, 0x6e, 0xe2, 0x80, 0x99, 0x65, 0x6e,
                          0x20, 0x73, 0x61, 0x69, 0x74, 0x20, 0x72, 0x69, 0x65,
                          0x6e, 0x2e, 0x20, 0x54, 0x6f, 0x75, 0x74, 0x65, 0x20,
                          0x6e, 0x6f, 0x74, 0x72, 0x65, 0x20, 0x64, 0x69, 0x67,
                          0x6e, 0x69, 0x74, 0xc3, 0xa9, 0x20, 0x63, 0x6f, 0x6e,
                          0x73, 0x69, 0x73, 0x74, 0x65, 0x20, 0x64, 0x6f, 0x6e,
                          0x63, 0x20, 0x65, 0x6e, 0x20, 0x6c, 0x61, 0x20, 0x70,
                          0x65, 0x6e, 0x73, 0xc3, 0xa9, 0x65, 0x2e, 0x20, 0x43,
                          0xe2, 0x80, 0x99, 0x65, 0x73, 0x74, 0x20, 0x64, 0x65,
                          0x20, 0x6c, 0xc3, 0xa0, 0x20, 0x71, 0x75, 0xe2, 0x80,
                          0x99, 0x69, 0x6c, 0x20, 0x66, 0x61, 0x75, 0x74, 0x20,
                          0x6e, 0x6f, 0x75, 0x73, 0x20, 0x72, 0x65, 0x6c, 0x65,
                          0x76, 0x65, 0x72, 0x20, 0x65, 0x74, 0x20, 0x6e, 0x6f,
                          0x6e, 0x20, 0x64, 0x65, 0x20, 0x6c, 0xe2, 0x80, 0x99,
                          0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x65, 0x74,
                          0x20, 0x64, 0x65, 0x20, 0x6c, 0x61, 0x20, 0x64, 0x75,
                          0x72, 0xc3, 0xa9, 0x65, 0x2c, 0x20, 0x71, 0x75, 0x65,
                          0x20, 0x6e, 0x6f, 0x75, 0x73, 0x20, 0x6e, 0x65, 0x20,
                          0x73, 0x61, 0x75, 0x72, 0x69, 0x6f, 0x6e, 0x73, 0x20,
                          0x72, 0x65, 0x6d, 0x70, 0x6c, 0x69, 0x72, 0x2e, 0x20,
                          0x54, 0x72, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x6c, 0x6f,
                          0x6e, 0x73, 0x20, 0x64, 0x6f, 0x6e, 0x63, 0x20, 0xc3,
                          0xa0, 0x20, 0x62, 0x69, 0x65, 0x6e, 0x20, 0x70, 0x65,
                          0x6e, 0x73, 0x65, 0x72, 0x20, 0x3a, 0x20, 0x76, 0x6f,
                          0x69, 0x6c, 0xc3, 0xa0, 0x20, 0x6c, 0x65, 0x20, 0x70,
                          0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x65, 0x20, 0x64,
                          0x65, 0x20, 0x6c, 0x61, 0x20, 0x6d, 0x6f, 0x72, 0x61,
                          0x6c, 0x65, 0x2e, 0xa6, 0x61, 0x72, 0x72, 0x61, 0x79,
                          0x30, 0x90, 0xa6, 0x61, 0x72, 0x72, 0x61, 0x79, 0x31,
                          0x91, 0xa3, 0x66, 0x6f, 0x6f, 0xa6, 0x61, 0x72, 0x72,
                          0x61, 0x79, 0x38, 0xdc, 0x00, 0x15, 0x01, 0x02, 0x04,
                          0x08, 0x10, 0x20, 0x40, 0xcc, 0x80, 0xcd, 0x01, 0x00,
                          0xcd, 0x02, 0x00, 0xcd, 0x04, 0x00, 0xcd, 0x08, 0x00,
                          0xcd, 0x10, 0x00, 0xcd, 0x20, 0x00, 0xcd, 0x40, 0x00,
                          0xcd, 0x80, 0x00, 0xce, 0x00, 0x01, 0x00, 0x00, 0xce,
                          0x00, 0x02, 0x00, 0x00, 0xce, 0x00, 0x04, 0x00, 0x00,
                          0xce, 0x00, 0x08, 0x00, 0x00, 0xce, 0x00, 0x10, 0x00,
                          0x00, 0xa4, 0x6d, 0x61, 0x70, 0x30, 0x80, 0xa4, 0x6d,
                          0x61, 0x70, 0x31, 0x81, 0xa3, 0x66, 0x6f, 0x6f, 0xa3,
                          0x62, 0x61, 0x72};


    int32_t test_mode = 0;
    printf("Select the test payload mode (0 - without payload, 1 - short payload msg, 2 - long payload msg): ");
    scanf("%d", &test_mode);

    int successful_results = 0;
    int rqst_count = 0;
    int sent_bytes = 0;
    // Sending loop
    printf("Start sending data...\n");
    while (TRUE)
    {
        uint8_t test_result = FALSE;
        switch (test_mode) {
        //"test_without_payload"
        case 0:
        {

        }
        //"test_short_data"
        case 1:
        {
            char* cmd_name                      = "SEND_SHORT_DATA_TEST";
            char* data                          = short_data;
            uint32_t data_size                  = sizeof (short_data);
            char* data_type                     = "blob";
            uint8_t is_check_crc                = FALSE; //check crc disabled
            uint8_t is_confirmation             = FALSE; //confirmation disabled
            uint8_t is_one_answ                 = TRUE; //wait only one answer
            uint32_t waiting_time               = 1000; //ms
            smart_answ_callback answ_clb        = smart_short_data_callback;
            smart_timeout_callback timeout_clb  = smart_short_data_timeout_callback;
            smart_free_callback free_clb        = smart_short_data_free_result_callback;

            smart_msg_t* msg = smart_create_rqst_msg(cmd_name, data, data_size, data_type,
                                                     is_check_crc, is_confirmation, is_one_answ,
                                                     waiting_time,
                                                     answ_clb, timeout_clb, free_clb);

            // Send test msg
            if (!smart_channel_send_msg(&channel, msg))
                printf("No data has been sent.\n");
            else
                rqst_count++, sent_bytes+= (int)sizeof(short_data),
                printf("%d - Requests were sent. Total sent traffic: %d bytes\n", rqst_count, sent_bytes);

            void* result = smart_get_result_to_rqst_msg(&channel, msg, waiting_time);
            if (result != NULL)
            {
                typedef struct
                {
                    char* received_data;
                }answer;

                if (strcmp(((answer*)result)->received_data, "HELLO, SHORT DATA TEST!") == 0)
                {
                    // Cleanup test msg
                    smart_cleanup_msg(msg);
                    free(msg); msg = NULL;
                    test_result = TRUE;
                }else
                {
                    // Cleanup test msg
                    smart_cleanup_msg(msg);
                    free(msg); msg = NULL;
                    test_result = FALSE;
                }
            }

            if (test_result)
                successful_results++;

            printf("%d - successful results.\n", successful_results);

        }
        //"test_long_data"
        case 2:
        {

        }
        default:
            break;
        }



    }

    return 0;
}
